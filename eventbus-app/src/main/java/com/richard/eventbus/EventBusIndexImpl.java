package com.richard.eventbus;

import com.richard.eventbus.framework.EventBusIndex;
import com.richard.eventbus.framework.EventHandlerClassInfo;
import com.richard.product.events.ProductCategoryCreatedEvent;
import com.richard.product.events.ProductCreatedEvent;
import com.richard.product.events.ProductDeactivatedEvent;
import com.richard.product.events.ProductUpdatedEvent;
import com.richard.product.events.listener.ProductCategoryCreatedEventListener;
import com.richard.product.events.listener.ProductCreatedEventListener;
import com.richard.product.events.listener.ProductCreatedEventLoggerListener;
import com.richard.product.events.listener.ProductDeactivatedEventListener;
import com.richard.product.events.listener.ProductUpdatedEventListener;

import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * this is auto generated by annotation processing.
 */
@Deprecated
public class EventBusIndexImpl implements EventBusIndex {
    // https://commons.apache.org/proper/commons-collections/jacoco/org.apache.commons.collections4.map/MultiValueMap.java.html

    public static Map<Class<?>, Set<EventHandlerClassInfo>> eventHandlers;

    static {
        eventHandlers = new ConcurrentHashMap<>(
            Map.ofEntries(
                Map.entry(ProductCreatedEvent.class, Set.of(
                        new EventHandlerClassInfo(ProductCreatedEvent.class, ProductCreatedEventLoggerListener.class, "on"),
                        new EventHandlerClassInfo(ProductCreatedEvent.class, ProductCreatedEventListener.class, "on")
                    )
                ),
                Map.entry(ProductDeactivatedEvent.class, Set.of(
                        new EventHandlerClassInfo(ProductDeactivatedEvent.class, ProductDeactivatedEventListener.class, "on")
                    )
                ),
                Map.entry(ProductCategoryCreatedEvent.class, Set.of(
                        new EventHandlerClassInfo(ProductCategoryCreatedEvent.class, ProductCategoryCreatedEventListener.class, "on")
                    )
                ),
                Map.entry(ProductUpdatedEvent.class, Set.of(
                        new EventHandlerClassInfo(ProductUpdatedEvent.class, ProductUpdatedEventListener.class, "on")
                    )
                )
            )
        );
    }

    @Override
    public Collection<EventHandlerClassInfo> getEventHandlerClass(Class<?> eventClass) {
        return eventHandlers.getOrDefault(eventClass, Set.of());
    }

    @Override
    public Collection<EventHandlerClassInfo> getAllEventHandlerClassInfos() {
        return eventHandlers.values().stream().flatMap(Collection::stream).toList();
    }

    @Override
    public void put(EventHandlerClassInfo eventClassInfo) {
        Objects.requireNonNull(eventClassInfo, "Event class info cannot be null");
        Set<EventHandlerClassInfo> eventHandlerClassInfos = eventHandlers.get(eventClassInfo.eventClass());
        if (eventHandlerClassInfos == null) {
            eventHandlerClassInfos = Set.of(eventClassInfo);
        } else {
            eventHandlerClassInfos = new HashSet<>(eventHandlerClassInfos);
            // it may contain the same object but without a handler, in this case we have to replace it with an object
            // that is newer and may have all its fields set up.
            eventHandlerClassInfos.remove(eventClassInfo);
            eventHandlerClassInfos.add(eventClassInfo);
        }
        eventHandlers.put(eventClassInfo.eventClass(), eventHandlerClassInfos);
    }

    @Override
    public String metrics() {
        StringBuilder result = new StringBuilder();
        for (Map.Entry<Class<?>, Set<EventHandlerClassInfo>> entry : eventHandlers.entrySet()) {
            result.append(String.format("Event Class: %s, Number of Handlers %d\n", entry.getKey().getSimpleName(), entry.getValue().size()));
        }
        return result.toString();
    }
}
